# A-Eye Architecture

This document outlines the architecture for A-Eye, an intent-driven development agent built into the A-Eye CLI.

## 1. Vision and Principles

A-Eye is designed to help a broad range of users, including non-developers, accomplish software development tasks by translating natural language intent into safe, repeatable, and verifiable workflows.

It is governed by four core principles:

- **Safety First**: The system is non-dev-safe by default. No action is taken without passing through policy gates and receiving explicit user approval. There is no autonomous execution.
- **Determinism**: A-Eye prioritizes structured, repeatable workflows (recipes) over open-ended agentic behavior. This ensures predictability and reliability.
- **Transparency**: Every step of a run—from planning to verification—is logged to a structured artifact store. The user can always see what the agent is doing, why it's doing it, and what the result was.
- **User Control**: The user is always in command. A-Eye provides plans and explanations, but the user makes the final decisions.

## 2. High-Level Architecture

A-Eye follows a structured, linear workflow for every user request.

**Workflow:** `Intent` -> `System Scan` -> `Plan` -> `Explain` -> `Patch` -> `Approve` -> `Apply` -> `Verify` -> `Learn`

### Components

- **CLI (`a-eye` command group)**: The primary user interface. It exposes commands like `scan`, `plan`, `apply`, etc.
- **System Scanner**: Analyzes the repository to build a `SystemProfile`. It detects languages, frameworks, build tools, test commands, and potential risk zones. This grounds the agent in reality.
- **Policy Engine**: The safety gatekeeper. It evaluates every proposed action against a user-defined policy (`a-eye.yaml`) and the current execution tier. It manages approval flows.
- **Workflow Engine**: A recipe runner that executes deterministic workflows defined in YAML. It orchestrates calls to other components and tools.
- **Artifact Store**: A local directory (`.nlpg/runs/<run_id>/`) that stores all inputs, outputs, logs, and metadata for a given run, ensuring full auditability.

## 3. Data Contracts

A-Eye operates on a set of well-defined data structures, which are persisted as JSON artifacts.

- **`a-eye.yaml` (Policy)**: The root configuration file defining safety rules.
  - `default_tier`: The permission level for new runs (e.g., `1`).
  - `write_allowlist`: Globs for files A-Eye is allowed to modify.
  - `shell_deny_patterns`: Regex patterns for shell commands that are never allowed.
  - `require_branch_for_apply`: If `true`, `a-eye apply` must create a new git branch.

- **`Intent`**: Captures the user's initial request.
  - `goal`: The natural language objective.
  - `scope`: File globs limiting the operational area.
  - `risk_tolerance`: `low` | `medium` | `high`.

- **`SystemProfile`**: The ground truth of the repository, generated by `a-eye scan`.
  - `repo_type`, `languages`, `frameworks`, `verify_commands`, `write_allowlist`.

- **`Plan`**: A structured, step-by-step plan generated by an LLM to achieve the `Intent`.

- **`StepResult`**: The output of a single step in a plan or recipe.

## 4. Execution Tiers

Tiers enforce the principle of least privilege.

- **Tier 0 (Explain-Only)**: Can only run `a-eye explain`. No file system reads (beyond the specified file), no writes, no shell execution.
- **Tier 1 (Plan & Diff - Default)**: Can scan the repo, generate plans, and create patch diffs. **No file writes or shell execution.** `a-eye verify` will only print the commands it would run.
- **Tier 2 (Supervised Execution)**: Enables `a-eye apply` and `a-eye verify` with shell execution. Every write and shell command requires an explicit, interactive user approval prompt.
- **Tier 3 (Advanced)**: Reserved for future use cases with more advanced, but still gated, capabilities.

## 5. A-Eye Commands

- `a-eye scan`: Scans the repo and creates/updates `.nlpg/system.json`.
- `a-eye plan "<goal>"`: Creates a plan to achieve the goal.
- `a-eye explain <path>`: Provides a detailed explanation of a code construct.
- `a-eye patch --from <plan>`: Generates a patch file from a plan.
- `a-eye apply --from <patch>`: (Tier 2+) Applies a patch after user approval.
- `a-eye verify`: (Tier 2+) Runs verification commands after user approval.
- `a-eye run <recipe>`: Executes a deterministic workflow from the `recipes/` directory.
- `a-eye status`: Shows the current tier, policy, and last run ID.
- `a-eye learn --from <run_id>`: Generates a learning summary from a past run.

## 6. Workflow Recipes

Recipes are YAML files in the `recipes/` directory that define a sequence of steps. This makes complex operations repeatable and safe.

**Example: `safe_patch.yaml`**

```yaml
name: Safe Patch
description: "Generates and applies a patch with verification."
steps:
  - name: Scan System
    action: system.scan
  - name: Generate Plan
    action: llm.plan
    inputs:
      goal: "{{ user.goal }}"
  - name: Generate Patch
    action: llm.patch
    inputs:
      plan: "{{ steps.Generate Plan.outputs.plan_json }}"
  - name: Request Approval to Apply
    action: policy.approval
    inputs:
      prompt: "Apply the generated patch?"
      tier: 2
  - name: Apply Patch
    action: tools.apply_patch
    inputs:
      patch: "{{ steps.Generate Patch.outputs.patch_diff }}"
  - name: Run Verification
    action: tools.run_verify
```
